import ast
from astutils.models.heaps import Heap
from typing import List, Callable, Union, Tuple

def ast2heap(
    ast_tree: ast.AST,
    source: str = None,
    positional: bool = True,
    not_considered_leaves: List = [],
    padded = True,
) -> Heap:
    """Takes in input an Abstract Syntax Tree representing a Python program and return it represented with an Heap instance.
    
    Args:
        ast_tree (ast.AST): An Abstract Syntax Tree representing a Python program.
        source (str, optional): The original code used to build the AST. If not None the final heap will contain a field with the original code associated with the node. Defaults to None.
        positional (str, optional): Considered only if the source parameter is initialized. When positional is True, the field ```_heap_code``` of the final model will contain alias that replace the original value of each subtoken (For example, ```@11``` is a placeolder for the node with ```_heap_id=11```). Defaults to True.
        not_considered_leaves (list, optional): A list containing all the not desidered types. This could be used to reduce the heap size keeping only the wanted nodes. Defaults to [].
        padded (bool, optional): If True, the padding information in the source code will be preserved. Defaults to True.
     Returns:
        Heap: An Heap representing the input AST.
    """

    return Heap(ast_tree, source=source, positional=positional, not_considered_leaves=not_considered_leaves, padded=padded)

def decompose(heap: Heap, min_size=1, max_size=None, measure='nnodes') -> List[Heap]:

    """Given an heap representation of a tree generated by ```ast2heap```, return the list of subheaps where each sub heap correspond to a block of code starting without identation.

    Args:
        heap (Heap): A heap generated with ```astutils.ast2heap()```.
        min_size (int): A the size of the smallest subtree to retrieve. Defaults to 1.
        max_size (int): A the size of the biggest subtree to retrieve. Defaults to None (max size).
        measure (str): can be the ```nnodes``` (```min_size``` and ```max_size``` will be computed on the number of nodes) or ```ntokens```  (```min_size``` and ```max_size``` will be computed on the number of tokens). Defaults to ```nnodes```.
    Returns:
        list: A list of subheaps.
    """

    return heap.decompose(min_size=min_size, max_size=max_size, measure=measure)

def greedy_decompose(heap: Heap, min_size=1, max_size=None, mode='max', measure='ntokens') -> List[Heap]:

    """Given an heap representation of a tree generated by ```ast2heap```, return the list of subheaps where each sub heap correspond to a block of code starting without identation. It differs from ```scompose``` since in this case, the generated subtrees cannot overlap.

    Args:
        heap (Heap): A heap generated with ```astutils.ast2heap()```.
        min_size (int): A the size of the smallest subtree to retrieve. Defaults to 1.
        max_size (int): A the size of the biggest subtree to retrieve. Defaults to None (max size).
        mode (int): ```max``` or ```min```. In the first case we maximize the size of the output subtrees, in the second case the output subtrees are smallest as possible.
        measure (str): can be the ```nnodes``` (```min_size``` and ```max_size``` will be computed on the number of nodes) or ```ntokens```  (```min_size``` and ```max_size``` will be computed on the number of tokens). Defaults to ```nnodes```.
    Returns:
        list: A list of subheaps.
    """

    return heap.gredy_decomposition(min_size=min_size, max_size=max_size, mode=mode, measure=measure) 


def heap2code(heap: Heap) -> str:

    """Given an heap generated by ```ast2heap```, return a string representing the original code from wich the heap was originated.

    Args:
        heap (Heap): A heap generated with ```astutils.ast2heap()``` with ```source not None``` and ```positional == True```.

    Returns:
        str: A string representing the original code.
    """

    return "".join([t[0] for t in heap2tokens(heap)])


def heap2tokens(heap: Heap) -> List[Tuple[str, int, str]]:
    
    """Given an heap generated by ```ast2heap```, return a list of tuple containing the ordered list of tokens and their indexes and their grammar type.

    Args:
        heap (Heap): A heap generated with ```astutils.ast2heap()``` with ```source not None``` and ```positional == True```.

    Returns:
        List[Tuple[str, int, str]]: A list of tuple where each tuple is ```(segment of code, ast_node_id, ast_node_type)```.
    """
    
    return heap.get_heap_tuples() 


def heap2tokenized_tokens(heap: Heap, fn_tokenize: Callable[[str], List[str]], *args, **kwargs) -> List[Tuple[str, int, str]]:    
    """Given an heap generated by ```ast2heap```, return a list of tuple containing the ordered list of tokens tokenized with ```fn_tokenize```and their indexes and their grammar type.

    Args:
        heap (Heap): A heap generated with ```astutils.ast2heap()``` with ```source not None``` and ```positional == True```.
        fn_tokenize (Callable[Union[str, List], List]): A tokenization function.
        *args (): Tokenizer optional args.
        **kwargs (): Tokenizer optional kwargs.

    Returns:
        List[Tuple[str, int, str]]: A list of tuple where each tuple is ```(segment of code, ast_node_id, ast_node_type)```.
    """

    return heap.get_heap_tuples(heap, fn_tokenize=fn_tokenize, *args, **kwargs) 


def heap2ast(heap: Heap) -> ast.AST:

    raise NotImplementedError
